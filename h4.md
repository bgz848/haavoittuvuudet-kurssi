# H4
## X). https://www.youtube.com/watch?v=oTD_ki86c9I

Virtual koneessani ei ollut ennalta asennettuna JDK21 jotein ajoin komennon sen asentamiseen.
- Ghidra on NSA:n kehittämä avoimen lähdekoodin takaisinmallinnustyökalu binäärien analysointiin.
- Ennen Ghidraa voi kokeilla työkaluja kuten ltrace, strace ja objdump.
- Ghidra muuntaa binäärikoodin luettavampaan muotoon ja dekompiloi sen C-kielelle
- Analyysiä helpottaa merkkijonojen (Defined Strings) etsiminen ja muuttujien sekä funktioiden uudelleennimeäminen.

## A).

      sudo apt install openjdk-21-jdk
![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4a1.png)

Latasin uusimman version Ghidrasta GitHubista https://github.com/NationalSecurityAgency/ghidra/releases/tag/Ghidra_12.0.2_build

Siirryin sitten hakemistoon ja kykenin ajamaan Ghidran.

    ./ghidraRun
![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4a2.png)
## B).

Loin uuden Ghidra projektin.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4b1.png)

Valitsin `Non-Shared Project`, koska tehtävään ei tule koskemaan kukaan muu.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4b2.png)

Nimesin projektin yksinkertaisesti vain sen ohjelman nimeksi.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4b3.png)

Avasin packd ohjelmasta version jonka olin decompressoinut UPX ohjelmalla aikaisemmassa tehtävässä

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4b4.png)

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4b5.png)

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4b6.png)

Ajoin analyysin kaikilla perus asetuksilla.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4b7.png)

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4b8.png)

Ohjelmasta löytyi helposti Ghidran `Symbol Tree` funktion avulla.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4b9.png)

C koodia katsellessani tietyt osat pistivät silmään.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4b10.png)

    __isoc99_scanf(&DAT_0010201d,local_28);
Googlasin instructionin ja löysin https://cplusplus.com/reference/cstring/strcmp/
scanf funktion tallentaa käyttäjän näppäimistö inputin local_28 variableen

    iVar1 = strcmp(local_28,"piilos-AnAnAs");
strcmp vertailee kahta stringiä ja palauttaa nollan jos molemmat ovat identtiset.
https://cplusplus.com/reference/cstdio/scanf/

Eli ohjelma yksinkertaisesti vain tallentaa scanf:llä hankitun tekstin, ja vertaa sitä strcmp funktiolla tekstin salanan. Tämä palauttaa nollan jos teksti pätkät ovat identtiset.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4b11.png)

Nimesin integerin joka kertoo jos tekstit ovat identtiset (0) tai eroavat (-1) `iIsPasswordCorrect`

Nimesin tekstipätkän jonka ohjelma ottaa sisäänsä `passwordInput`

## C).

Korostin C koodista if statementin

    if (iVar1 == 0) {
Se kätevästi korostaa alkuperäisestä assemblystä merkittävät kohdat.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4c1.png)

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4c2.png)

JNZ? Googlasin "assembly jnz"

https://www.aldeid.com/wiki/X86-assembly/Instructions/jnz

    jnz is commonly used to explicitly test for something not being equal to zero whereas jne is commonly found after a cmp instruction.
Eli olisiko instructionin koko nimi `jump not zero`?
Googlen kautta etsin samaa sivua "aldeid.com", mutta tekemällä instructionista päinvastaisen `jump if zero`. Ja löysin tarvitsemani. https://www.aldeid.com/wiki/X86-assembly/Instructions/jz

    jz is commonly used to explicitly test for something being equal to zero whereas je is commonly found after a cmp instruction.

Muutin komennon `JNZ` komennoksi `JZ`

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4c3.png)

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4c4.png)

Tallensin muokatun ohjelman.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4c5.png)

Ajoin muokatun ohjelman ja se toimi odotetulla tavalla.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4c6.png)

## D).
Git ei ollut ennalta asennettu joten asensin sen.

    sudo apt-get install git

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4d1.png)

Kloonasin repotorion.

    git clone https://github.com/NoraCodes/crackmes

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4d2.png)

Siirryin kansioon.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4d3.png)

Ja käänsin koodit ohjelmiksi.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4d4.png)

## E).
Ajoin ohjelman ensiksi.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4e1.png)

Katsoin Ghirdan decompiler näkymään ja salasana password1 näkyi heti.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4e2.png)

Testasin salasanaa ja se toimi.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4e3.png)

Ajoin ohjelman crackme01e. Se kertoi vaatimuksensa.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4e4.png)

Katsoin jos salasanan löytäisi koodista. Sen löysi heti.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4e5.png)

Mutta yrittäessä ajaa sen Bash esti. 

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4e6.png)

Jouduin lisäämään merkin huutomerkin eteen, että se menisille ohjelmalle eikä pidettäisi komentona.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4e7.png)

## F).

Aloitin ajamalla ohjelman.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4f1.png)
![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4f2.png)

Ensimmäiseksi tarkastelin koodin yksinkertaisinta osuutta, eli if–else-rakennetta. Päätin testata ohjelmaa ajamalla sen useammalla kuin yhdellä parametrillä.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4f3.png)

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4f4.png)

Kun ohjelma ajetaan ilman parametreja tai useammalla kuin yhdellä parametrillä, se tulostaa virheilmoituksen:

    Need exactly one argument.

Nimesin parametrin aluksi ?Parametrienmäärä, koska en ollut vielä varma sen tarkoituksesta.

Koodia tarkastellessani huomasin seuraavan rivin:

    uVar3 = 0xffffffff;

Tämä vaikutti oudolta, koska aiemmin samassa koodissa esiintyi:

    uVar3 = 0;

Päätin testata arvon merkitystä online-hexadesimaalimuuntimella:
[https://www.rapidtables.com/convert/number/hex-to-decimal.html?x=FFFFFFFF](https://www.rapidtables.com/convert/number/hex-to-decimal.html?x=FFFFFFFF)

Tulokseksi sain:

    -1

Tästä päättelin, että arvo liittyy funktion return-arvoon ja todennäköisesti edustaa virhetilaa tai erityistä paluuarvoa.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4f5.png)

Seuraavaksi keskityin do while -silmukkaan. Muuttuja lVar3 on ainoa numeerinen muuttuja silmukan sisällä, ja siihen lisätään yksi jokaisella kierroksella. Tämä viittaa siihen, että kyseessä on todennäköisesti iteraatiolaskuri.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4f6.png)

Silmukan ehtona on:

    } while (cVar2 != '\0');

Tämä ei ollut minulle ennestään tuttu, mutta googlattuani merkkijonon "\0"
[https://stackoverflow.com/questions/14461695/what-does-0-stand-for](https://stackoverflow.com/questions/14461695/what-does-0-stand-for)
selvisi, että kyseessä on C-kielen null-terminaattori eli merkkijonon loppu.

Tämä tarkoittaa, että koodi käy syötteen läpi merkki kerrallaan ja jatkaa silmukkaa niin kauan kuin nykyinen merkki ei ole merkkijonon loppu. Kokonainen sana ei voi olla null, joten vertailu kohdistuu yksittäiseen merkkiin kerrallaan.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4f7.png)

Jäljelle jää muuttuja:

    char cVar1;

Tämän on pakko olla tavalla tai toisella verrattavissa syötteeseen.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4f8.png)

Tässä vaiheessa jäin kuitenkin jumiin. Parametri param_2 oli tyyppiä long, eli numeerinen arvo eikä suoraan tekstiä. En ymmärtänyt, miten syötteenä annettu merkkijono muunnetaan numeroksi (tai osoitteeksi) ja miten sitä käsitellään edelleen koodissa.

![](https://raw.githubusercontent.com/bgz848/haavoittuvuudet-kurssi/refs/heads/main/4f9.png)

Nimesin toisen parametrin input, mutta en silti täysin hahmottanut, miten teksti muutetaan koodissa käsiteltävään muotoon ja miten se muunnetaan takaisin.


## Lähteet
https://cplusplus.com/reference/cstring/strcmp/
https://cplusplus.com/reference/cstdio/scanf/
